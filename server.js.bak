import express from "express";
import crypto from "node:crypto";
import { execFile } from "node:child_process";
import fs from "node:fs";
import path from "node:path";

const app = express();
const PORT = process.env.PORT || 10000;
const PROCESSOR_TOKEN = process.env.PROCESSOR_TOKEN || "";
const SLACK_BOT_TOKEN = process.env.SLACK_BOT_TOKEN || "";

// Optional: base64 Netscape cookies file (if needed later)
const COOKIES_B64 = process.env.YTDLP_COOKIES_B64 || "";
let COOKIES_PATH = "";
if (COOKIES_B64) {
  COOKIES_PATH = "/tmp/yt_cookies.txt";
  try { fs.writeFileSync(cookiesPath, Buffer.from(COOKIES_B64, "base64")); } catch {}
}

// capture raw body (for HMAC)
app.use(express.json({ limit: "8mb", verify: (req, _res, buf) => { req.rawBody = buf; } }));

function hmacHex(key, msgUtf8) {
  return crypto.createHmac("sha256", key).update(msgUtf8, "utf8").digest("hex");
}
function timingSafeEq(a, b) {
  try {
    const A = Buffer.from(a); const B = Buffer.from(b);
    if (A.length !== B.length) return false;
    return crypto.timingSafeEqual(A, B);
  } catch { return false; }
}
function isAuthorized(req) {
  const auth = req.headers.authorization || "";
  const bearer = auth.startsWith("Bearer ") ? auth.slice(7) : "";
  if (bearer && bearer === PROCESSOR_TOKEN) return true;
  const sig = req.headers["x-isolator-signature"];
  if (sig && req.rawBody && PROCESSOR_TOKEN) {
    const want = hmacHex(PROCESSOR_TOKEN, req.rawBody.toString("utf8"));
    if (timingSafeEq(String(sig), want)) return true;
  }
  return false;
}

async function slackPost(token, payload) {
  if (!token) return;
  try {
    await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: { "Authorization": `Bearer ${token}`, "Content-Type": "application/json;charset=utf-8" },
      body: JSON.stringify(payload)
    });
  } catch {}
}

// ---- yt-dlp with anti-bot fallback -----------------------------------------
function run(cmd, args) {
  return new Promise((resolve, reject) => {
    execFile(cmd, args, { env: process.env }, (err, stdout, stderr) => {
      const out = (stdout || "") + (stderr || "");
      if (err) {
        console.log("CMD FAIL:", cmd, args.join(" "));
        console.log(out.trim());
        reject(new Error(out.trim() || err.message));
        return;
      }
      console.log(out.trim() || `${cmd} done`);
      resolve(out);
    });
  });
}

// Download bestaudio as m4a directly (no ffmpeg), using cookies if present
async function downloadAudioResilient(youtubeUrl, cookiesPath) {
  const args = ["-m", "yt_dlp"];

  // attach cookies if the file exists and is non-empty
  try {
    if (cookiesPath && fs.existsSync(cookiesPath) && fs.statSync(cookiesPath).size > 0) {
      args.push("--cookies", cookiesPath);
    }
  } catch {}

  // prefer m4a, fall back to any bestaudio
  args.push(
    "-f", "bestaudio[ext=m4a]/bestaudio",
    "-o", "/tmp/source.%(ext)s",
    youtubeUrl
  );

  await run("python3", args);

  // pick the file yt-dlp actually wrote
  for (const ext of ["m4a", "mp4", "webm"]) {
    const guess = `/tmp/source.${ext}`;
    if (fs.existsSync(guess)) return guess;
  }
  throw new Error("No downloaded source found in /tmp");
}

// ---------------------------------------------------------------------------

app.get("/health", (_req, res) => res.json({ ok: true }));

app.post("/", async (req, res) => {
if (!isAuthorized(req)) {
  return res.status(401).json({ ok: false, error: "unauthorized" });
}

// include cookies_b64 from body; keep other fields
const { mode, url, title, channel, thread_ts } = req.body || {};
const cookies_b64 = (req.body && req.body.cookies_b64) || req.headers["x-isolator-cookies-b64"];
console.log("INTAKE", { mode, url, title, channel, thread_ts });
// optional cookie file for yt-dlp anti-bot
let COOKIES_PATH_REQ = "";
try {
  if (cookies_b64) {
    const raw = Buffer.from(String(cookies_b64), "base64");
    COOKIES_PATH_REQ = "/tmp/yt_cookies.txt";
    require("node:fs").writeFileSync(COOKIES_PATH_REQ, raw);
    console.log("COOKIE FILE WRITTEN", { path: COOKIES_PATH_REQ, bytes: raw.length });
  } else {
    console.log("NO COOKIES PROVIDED");
  }
} catch (e) {
  console.error("COOKIE WRITE ERROR", e);
}

// fast ACK

res.json({ ok: true, intake: true, mode, url, title });

try {
  const src = await downloadAudioResilient(url, cookiesPath);
  console.log("DOWNLOADED", src);

    // ---- Demucs (placeholder) ----
    // TODO: run actual demucs command; for now just log done markers.
    const outDir = "/tmp/demucs_out";
    try { fs.mkdirSync(outDir, { recursive: true }); } catch {}
    const vocalOut = path.join(outDir, "vocals.wav");
    const instrOut = path.join(outDir, "no_vocals.wav");
    console.log("DEMUX DONE", { vocalOut, instrOut });

    if (channel && thread_ts) {
      await slackPost(SLACK_BOT_TOKEN, {
        channel, thread_ts,
        text: "✅ Split complete. Uploading stems…"
      });
      await slackPost(SLACK_BOT_TOKEN, {
        channel, thread_ts,
        text: "✅ Stems ready (vocals / instrumental)."
      });
    }
  } catch (e) {
    console.error("PROCESS ERROR", e);
    if (channel && thread_ts) {
      await slackPost(SLACK_BOT_TOKEN, {
        channel, thread_ts,
        text: `❌ Processor error: ${(e && e.message) ? e.message : String(e)}`
      });
    }
  }
});

app.listen(PORT, () => console.log(`processor up on ${PORT}`));

// 413 handler for large JSON bodies (cookies_b64 can be big)
app.use(function (err, req, res, next) {
  if (err && err.type === "entity.too.large") {
    return res.status(413).json({ ok:false, error:"payload_too_large" });
  }
  next(err);
});

// 413 handler for large JSON bodies (cookies_b64)
app.use(function (err, req, res, next) {
  if (err && err.type === "entity.too.large") {
    return res.status(413).json({ ok:false, error:"payload_too_large" });
  }
  next(err);
});
